# 微信智能日程助手 - 项目介绍

> 基于 LangChain + LangGraph + 智谱 GLM 的微信智能日程管理机器人

---

## 项目概述

| 项目信息 | 详情 |
|---------|------|
| **项目名称** | 微信智能日程助手 (WXzhushou) |
| **项目类型** | AI Agent 应用 |
| **技术栈** | Python / FastAPI / LangChain 1.2 / LangGraph 1.0 / SQLAlchemy 2.0 / APScheduler / 智谱 GLM-4 |
| **开发周期** | 2026.01 - 2026.02 |
| **项目版本** | v3.0.0 |
| **代码规模** | ~2000 行核心代码 / 8 个服务模块 / 6 种操作类型 |

### 一句话介绍
基于 LangChain + LangGraph 构建的智能日程管理 Agent，采用「意图检测 + 结构化执行」分离架构，通过微信公众号实现自然语言交互，支持日程智能创建、查询、修改、删除及个性化定时提醒。

---

## 核心功能

- **智能对话**：基于大语言模型的自然语言交互，支持多轮对话上下文
- **日程管理**：通过自然语言完成日程的增删改查（CRUD）
- **智能提醒**：每日日程汇总提醒 + 日程开始前定时提醒
- **语音支持**：语音消息转文字处理（智谱 ASR）
- **个性化设置**：可配置提醒时间、提前提醒分钟数等

---

## 技术亮点

### 1. AI Agent 架构设计（LangChain + LangGraph）

采用 **LangGraph 状态图** 驱动的 Agent 架构，实现「意图检测与执行分离」：

```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  用户消息   │───▶│  意图检测   │───▶│  操作执行   │───▶ 返回结果
│  (Input)    │    │  (LLM)      │    │ (Executor)  │
└─────────────┘    └─────────────┘    └─────────────┘
                          │
                    结构化 JSON
                    {reply, action}
```

**LangGraph 核心设计**：
- **State（状态）**：定义 Agent 运行时的状态结构，包含消息历史、当前意图、执行结果
- **Node（节点）**：意图检测节点、执行器节点、回复生成节点
- **Edge（边）**：根据意图类型路由到不同执行分支（create/query/update/delete）
- **Conditional Edge**：根据 `action.type` 动态选择执行路径

```python
from langgraph.graph import StateGraph, END

# 定义状态
class AgentState(TypedDict):
    messages: List[BaseMessage]
    intent: Optional[ScheduleAction]
    result: Optional[str]

# 构建状态图
workflow = StateGraph(AgentState)
workflow.add_node("detect_intent", detect_intent_node)
workflow.add_node("execute_action", execute_action_node)
workflow.add_conditional_edges(
    "detect_intent",
    route_by_intent,  # 根据 action.type 路由
    {
        "create": "execute_create",
        "query": "execute_query",
        "chat": END  # 普通聊天直接结束
    }
)
```

**技术要点**：
- 使用 LangChain `ChatOpenAI` 适配智谱 GLM API（OpenAI 兼容接口）
- Pydantic 定义结构化输出模型（`AIOutput` / `ScheduleAction`）
- Prompt Engineering 实现零样本意图识别
- JSON 输出解析 + 多层容错机制

```python
class AIOutput(BaseModel):
    """LLM 结构化输出"""
    reply: str = Field(description="给用户的回复")
    action: Optional[ScheduleAction] = Field(default=None)

class ScheduleAction(BaseModel):
    """日程操作指令"""
    type: Literal["create", "query", "update", "delete", "settings"]
    title: Optional[str] = None
    time: Optional[str] = None
    target: Optional[str] = None
```

### 2. 高度可扩展的插件化架构

采用「**工具注册 + 执行器分发**」模式，新增功能只需两步：

**扩展机制**：
```python
# 1. 定义新的 Action 类型
class ScheduleAction(BaseModel):
    type: Literal["create", "query", "update", "delete", "settings",
                  "weather", "note", "todo"]  # 新增类型

# 2. 在执行器中添加处理方法
class ScheduleExecutor:
    async def _execute_action(self, action: ScheduleAction, ...):
        handlers = {
            "create": self._handle_create,
            "query": self._handle_query,
            "weather": self._handle_weather,  # 新增
            "note": self._handle_note,        # 新增
        }
        return await handlers.get(action.type, self._default)(action, ...)
```

**可扩展性设计**：
| 扩展点 | 方式 | 示例 |
|--------|------|------|
| 新增操作类型 | 添加 Action 字段 + Handler 方法 | 天气查询、备忘录 |
| 新增消息渠道 | 实现 Channel Adapter | Telegram、钉钉 |
| 新增存储后端 | 实现 Repository 接口 | PostgreSQL、MongoDB |
| 新增 LLM | 实现 LLM Provider | OpenAI、Claude |

**接口抽象示例**：
```python
# 存储层抽象
class ScheduleRepository(Protocol):
    async def create(self, schedule: Schedule) -> Schedule: ...
    async def query(self, user_id: str, date: date) -> List[Schedule]: ...

# 渠道抽象
class MessageChannel(Protocol):
    async def send(self, user_id: str, content: str) -> bool: ...
    async def receive(self) -> AsyncIterator[Message]: ...
```

### 3. 中文自然语言时间解析器

自主研发支持丰富中文时间表达的解析器，覆盖 **100+ 种**中文时间表达：

**支持的表达类型**：
| 类型 | 示例 | 解析结果 |
|------|------|----------|
| 相对日期 | 今天、明天、后天、大后天、大前天 | 2026-02-13 |
| 周相关 | 这周五、下周三、下下周一、上周日 | 2026-02-14 |
| 月日格式 | 3月15日、三月十五号、3/15、3-15 | 2026-03-15 |
| 时间段推断 | 凌晨/早上/上午/中午/下午/晚上/深夜 | 推断小时数 |
| 中文数字 | 三点、十五分、三点半、一刻、三刻 | 03:00/15:30 |
| 组合表达 | 下周五下午三点半、明天早上8点 | 完整 datetime |

**核心技术**：
- 正则表达式 + 规则引擎（按优先级匹配）
- 中文数字转换（按长度降序，避免"十一"→"1"+"1"）
- 时间段默认值推断（"下午" → 15:00）
- dateparser 库作为兜底 fallback

```python
# 解析复杂时间表达
parse_time("下周五下午三点半")  # → 2026-03-06 15:30:00
parse_time("明天早上")          # → 2026-02-13 07:00:00
parse_time("3月15号晚上十点一刻") # → 2026-03-15 22:15:00
```

### 4. 动态定时任务调度系统

基于 APScheduler 实现的**多层次、用户级别**提醒系统：

**架构设计**：
```
┌────────────────────────────────────────────────────────┐
│                 ReminderService                         │
├────────────────────────────────────────────────────────┤
│  ┌─────────────────┐    ┌─────────────────┐           │
│  │  每日提醒任务    │    │  日程前提醒      │           │
│  │  (CronTrigger)  │    │  (IntervalScan) │           │
│  └─────────────────┘    └─────────────────┘           │
│         │                      │                       │
│    每用户独立任务          每分钟扫描                    │
│    支持动态重调度          动态触发                     │
└────────────────────────────────────────────────────────┘
```

**技术要点**：
- **每日提醒**：为每个用户创建独立的 `CronTrigger` 任务（如 user_001 → 08:00）
- **日程前提醒**：每分钟扫描即将开始的日程，根据用户设置动态触发
- **任务追踪**：`Set[str]` 跟踪已发送提醒，避免重复
- **动态重调度**：用户修改设置时，自动销毁旧任务、创建新任务
- **内存管理**：`call_later(300, cleanup)` 延迟清理，防止泄漏

```python
async def _reschedule_user_daily_reminder(self, user_settings: UserSettings):
    """用户修改设置后自动重新调度"""
    job_id = f"daily_reminder_{user_settings.user_id}"

    # 销毁旧任务
    if job_id in self._daily_reminder_jobs.values():
        self.scheduler.remove_job(job_id)

    # 创建新任务
    self.scheduler.add_job(
        self._send_daily_reminder,
        CronTrigger(hour=hour, minute=minute),
        id=job_id,
        replace_existing=True
    )
```

### 5. 全异步架构（End-to-End Async）

端到端异步设计，**单进程支持数百并发连接**：

| 层级 | 技术 | 异步方式 |
|------|------|----------|
| Web 层 | FastAPI + Uvicorn | ASGI 原生异步 |
| 数据库 | SQLAlchemy 2.0 + aiosqlite | async/await |
| HTTP 客户端 | httpx | AsyncClient |
| 定时任务 | APScheduler | AsyncIOScheduler |
| LLM 调用 | LangChain | `ainvoke()` |

```python
# 异步数据库操作
async with AsyncSessionLocal() as db:
    result = await db.execute(
        select(Schedule).where(Schedule.user_id == user_id)
    )
    schedules = result.scalars().all()

# 异步 LLM 调用
response = await self.llm.ainvoke(messages)
```

### 6. 微信公众号完整集成

实现微信公众号的**双向通信**能力：

**消息接收（被动响应）**：
- XML 解析 + 签名验证（防止伪造请求）
- 消息类型路由（文本/语音/图片）
- 5 秒响应限制处理

**消息推送（主动发送）**：
- 客服消息接口（48 小时内可主动发送）
- access_token 缓存 + 自动刷新（提前 5 分钟）
- 模板消息支持（需认证服务号）

```python
# access_token 智能缓存
if self._token and datetime.now() < self._expires_at:
    return self._token  # 命中缓存

# 自动刷新，提前 5 分钟避免临界点失效
self._expires_at = datetime.now() + timedelta(seconds=expires_in - 300)
```

### 7. 多轮对话上下文管理

基于内存的高效对话历史管理：

- **用户隔离**：按 `user_id` 独立存储对话历史
- **长度限制**：保留最近 6 轮（12 条消息），防止 token 溢出
- **自动截断**：超出时保留最新消息

```python
# 更新历史 + 自动截断
self._history[user_id].extend([
    {"role": "user", "content": message},
    {"role": "assistant", "content": response}
])
if len(self._history[user_id]) > 12:
    self._history[user_id] = self._history[user_id][-12:]
```

---

## 技术难点与解决方案

### 难点 1：LLM 结构化输出稳定性

**问题**：LLM 输出的 JSON 格式不稳定，可能包含 markdown 代码块、多余空格、字段缺失等。

**解决方案**：
1. **Prompt Engineering**：明确要求 "只输出 JSON，不要输出其他内容"
2. **正则提取**：兼容 ```json 代码块和裸 JSON
3. **多层容错**：解析失败时将原始内容作为普通回复
4. **Pydantic 校验**：字段缺失时使用默认值

```python
def _parse_json_output(self, raw: str) -> AIOutput:
    # 1. 提取 JSON 内容
    if "```json" in raw:
        raw = re.search(r"```json\s*(.*?)\s*```", raw, re.DOTALL).group(1)

    # 2. 解析 + 容错
    try:
        data = json.loads(raw.strip())
        return AIOutput(**data)  # Pydantic 自动填充默认值
    except (json.JSONDecodeError, ValidationError):
        return AIOutput(reply=raw, action=None)  # 降级为普通回复
```

### 难点 2：中文时间解析的歧义性

**问题**："下周五下午三点" vs "周五下午三点"，用户表达模糊。

**解决方案**：
1. **分层解析**：日期解析 → 时间解析 → 合并结果
2. **优先级匹配**：周几匹配优先于基本关键词（避免"周五"被"今天"覆盖）
3. **时间段推断**："下午3点" → 15:00（+12 小时调整）
4. **历史顺延**：已过时间自动推迟到明天

```python
# 优先级：周几 > 日期关键词 > 月日
week_match = re.search(r'(下周|这周)?(周[一二三四五六日])', text)
if week_match:
    return self._parse_weekday(week_match)  # 最高优先级
```

### 难点 3：提醒任务的动态管理

**问题**：用户修改设置后，需要原子性地销毁旧任务、创建新任务。

**解决方案**：
1. **任务映射**：维护 `user_id → job_id` 字典
2. **原子操作**：先 `remove_job()` 再 `add_job(replace_existing=True)`
3. **幂等设计**：重复调用不会创建重复任务

### 难点 4：多用户并发数据隔离

**问题**：多用户同时操作，需确保数据安全隔离。

**解决方案**：
1. **查询条件**：所有 SQL 都带 `user_id` 过滤
2. **会话隔离**：每个请求独立的数据库会话
3. **对话隔离**：`defaultdict(list)` 按 user_id 分组

---

## 项目架构图

```
┌─────────────────────────────────────────────────────────────────────┐
│                          微信服务器                                  │
└────────────────────────────────┬────────────────────────────────────┘
                                 │ XML 消息
                                 ▼
┌─────────────────────────────────────────────────────────────────────┐
│                       FastAPI 应用层                                 │
│                   app/routers/wechat.py                             │
│            (XML解析 / 签名验证 / 消息路由)                            │
└────────────────────────────────┬────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────┐
│                    LangChain Agent 服务                              │
│               services/langchain_agent.py                           │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │              LangGraph 状态图驱动                               │  │
│  │  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐       │  │
│  │  │ 意图检测节点 │───▶│ 条件路由    │───▶│ 执行器节点   │       │  │
│  │  │ (LLM+JSON)  │    │ (by type)   │    │ (Handler)   │       │  │
│  │  └─────────────┘    └─────────────┘    └─────────────┘       │  │
│  └───────────────────────────────────────────────────────────────┘  │
└────────────────────────────────┬────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────┐
│                        业务服务层                                    │
│  ┌────────────┐ ┌────────────┐ ┌────────────┐ ┌────────────┐       │
│  │schedule_svc│ │reminder_svc│ │  asr_svc   │ │wechat_push │       │
│  │  (CRUD)    │ │ (定时任务)  │ │  (语音)    │ │  (推送)    │       │
│  └────────────┘ └────────────┘ └────────────┘ └────────────┘       │
└────────────────────────────────┬────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────┐
│                       数据持久层                                     │
│            SQLite + SQLAlchemy 2.0 (async)                          │
│         ┌──────────────┐         ┌──────────────┐                   │
│         │  schedules   │         │ user_settings │                   │
│         └──────────────┘         └──────────────┘                   │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 项目规模

| 指标 | 数据 |
|------|------|
| 核心代码行数 | ~2000 行 |
| 服务模块数量 | 8 个（agent/chat/executor/schedule/reminder/wechat/asr/push） |
| 数据模型数量 | 3 个（Schedule/UserSettings/Message） |
| API 接口数量 | 3 个（health/wechat-GET/wechat-POST） |
| 支持的操作类型 | 6 种（create/query/update/delete/settings/update_settings） |
| 支持的时间表达 | 100+ 种中文格式 |

---

## 项目成果

- 完整的 AI Agent 应用闭环：用户输入 → 意图识别 → 结构化执行 → 结果返回
- LangGraph 状态图驱动的可扩展架构，新增功能只需添加 Handler
- 自研中文时间解析器，覆盖 100+ 种表达格式
- 稳定的 LLM 结构化输出（JSON Schema + 多层容错）
- 完善的多层次提醒系统（每日汇总 + 日程前提醒）
- 全异步架构，单进程支持高并发

---

## 简历描述建议

### 版本一（简洁版 - 推荐）

> **微信智能日程助手** | Python / FastAPI / LangChain / LangGraph / 智谱 GLM
> - 基于 **LangChain + LangGraph** 构建 AI Agent，采用「意图检测 + 结构化执行」分离架构
> - 设计**插件化执行器模式**，新增功能只需添加 Action 类型 + Handler 方法，零侵入扩展
> - 自研中文时间解析器，正则 + 规则引擎覆盖 100+ 种表达（下周五下午三点半等）
> - APScheduler 实现用户级动态定时任务，支持个性化提醒 + 运行时重调度
> - 全异步架构（FastAPI + SQLAlchemy async + httpx），单进程支持数百并发

### 版本二（详细版）

> **微信智能日程助手** | Python / FastAPI / LangChain / LangGraph / SQLite
>
> 基于 LangChain + LangGraph 的智能日程管理应用，通过微信公众号实现自然语言交互。
>
> - **LangGraph Agent 架构**：状态图驱动，Conditional Edge 按意图类型路由，意图检测与执行分离
> - **插件化可扩展设计**：工具注册 + 执行器分发模式，新增功能只需 2 步（定义 Action + 实现 Handler）
> - **中文时间解析器**：自研解析器支持 100+ 种表达，分层解析 + 时间段推断 + 历史顺延
> - **动态任务调度**：每用户独立 Cron 任务，修改设置自动销毁旧任务、创建新任务
> - **全异步设计**：端到端异步（FastAPI + aiosqlite + httpx + LangChain ainvoke）
> - **微信公众号集成**：消息接收（XML 解析 + 签名验证）、主动推送（客服消息 + token 自动刷新）

### 版本三（面试引导版）

> **微信智能日程助手** | 独立开发 | Python / LangChain / LangGraph / FastAPI
>
> 一个 AI Agent 应用，用户通过微信公众号用自然语言管理日程（如"明天下午3点开会"）。
>
> **技术亮点**：
> 1. **LangGraph 状态图**：定义 AgentState → 构建节点 → 条件路由，实现可复用的 Agent 流程
> 2. **插件化架构**：执行器通过 `handlers[type]` 分发，新增天气/备忘录等功能无需改动核心代码
> 3. **LLM 结构化输出**：Prompt Engineering + Pydantic + 多层容错，解决 JSON 输出不稳定问题
> 4. **中文时间解析**：处理"下周五下午三点半"等复杂表达，结合正则优先级匹配 + dateparser 兜底
> 5. **动态任务调度**：每个用户独立 Cron 任务，运行时修改设置自动重新调度
>
> **面试可深挖的点**：
> - LangGraph 的 State/Node/Edge 如何设计？Conditional Edge 的实现原理？
> - 如何保证 LLM 输出格式的稳定性？解析失败时如何降级处理？
> - 插件化架构的设计思路？如何做到零侵入扩展？
> - 异步架构中数据库连接池的管理？APScheduler 的并发模型？

---

## 相关链接

- 项目仓库：[GitHub 私有仓库]
- 技术文档：[doc/](./) 目录
- AI Agent 流程详解：[ai_agent_flow.md](./ai_agent_flow.md)
- 数据库架构：[database_architecture.md](./database_architecture.md)

---

*文档版本：2.0*
*最后更新：2026-02-26*
